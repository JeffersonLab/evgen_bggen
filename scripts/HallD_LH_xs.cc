/*
Rakitha Beminiwattha Fri Nov 20 10:39:00 EST 2015
File name : HallD_LH_xs.cc uses proton target electro-production pions from Hall D generator to produce electro-production events for following target,
PVDIS H and D, SIDIS He, J/psi, SIDIS Proton, MOLLER proton. use targ_index parameter to select correct target

For now one has to set the hall d rootfile manually. use following rootfiles (files can be found at ifarm:/work/halla/solid/rakithab/halld/halld_rootfiles/) 

for PVDIS H and D, SIDIS 3He ,
set1               bggen_output_1M_*.root
set2 to 5          bggen_set*_output_1M_*.root

for moller
set1               bggen_set1_output_MOLLER_1M_*.root

for J/psi
set1               bggen_output_Jpsi_1M_*.root

Decode root files generated by hall d generator
This file produce kinematics plots for pions and output LUND files to be used for pion background simulations. Currently this script will generate pions and neutrons and protons background LUND files.

Max no.of pions per LUND file allowed for now is 1 million

Set of generated lund files are available at,
ifarm:/work/halla/solid/rakithab/halld/lund_format

that can be used to simulate pion background for SoLID and MOLLER targets.

for more information contact rakitha beminiwattha, rakithab@jlab.org
 */


#include <vector>
#include <string>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <new>
#include <cstdlib>
#include <math.h>
#include <stdio.h>

#include <TRandom.h>
#include <TRandom3.h>
#include <TApplication.h>
#include <TSystem.h>

#include <TH2F.h>
#include <TTree.h>
#include <TF1.h>
#include <TF2.h>
#include <TF3.h>
#include <TProfile.h>
#include <Rtypes.h>
#include <TROOT.h>
#include <TFile.h>
#include <TChain.h>
#include <TString.h> 
#include <TDatime.h>
#include <TStopwatch.h>
#include <stdexcept>
#include <time.h>
#include <cstdio>
#include <map>
#include <set>
#include <cassert>

#include <TMath.h>
#include <TStyle.h>
#include <TPaveStats.h>

#include <TCanvas.h>
#include <TLine.h>
#include <TGraph.h>
#include <TMultiGraph.h>
#include <TLegend.h>
#include <TGraphErrors.h>
#include <TFrame.h>
#include <TObjArray.h>
#include <TVector2.h>
#include <TVirtualFitter.h>
#include "wiser_pion.h"


using namespace std;

#define __IO_MAXHIT 10000
#define __TARGETS 6
#define __MOMENTUM_BINS 6
#define __MOMENTUM_BINS1 10

Double_t fEvQ2;
Double_t fEvW2;
Double_t fEvXbj;
Double_t Wprate,Wmrate,y;
Double_t Ef;
/*
Int_t fEv_num;
Double_t fEv_pz;
//for kinematic parameters
Int_t fEv_num;
Double_t fEvRate;
Double_t fEvQ2;
Double_t fEvW2;
Double_t fEvXbj;
Int_t fEvnpart;
Int_t fEvPID[__IO_MAXHIT];

//for generic hits from Remoll tree
Int_t fNGenDetHit;
Int_t fGenDetHit_det[__IO_MAXHIT];
Int_t fGenDetHit_trid[__IO_MAXHIT];
Int_t fGenDetHit_mtrid[__IO_MAXHIT];
Int_t fGenDetHit_pid[__IO_MAXHIT];
Double_t fGenDetHit_P[__IO_MAXHIT];
Double_t fGenDetHit_PX[__IO_MAXHIT];
Double_t fGenDetHit_PY[__IO_MAXHIT];
Double_t fGenDetHit_PZ[__IO_MAXHIT];
Double_t fGenDetHit_X[__IO_MAXHIT];
Double_t fGenDetHit_Y[__IO_MAXHIT];
Double_t fGenDetHit_Z[__IO_MAXHIT];
Double_t fGenDetHit_VZ[__IO_MAXHIT];
*/

//for ntuple from hall d code
// Declaration of leaf types
Int_t           ieve;
Int_t           irun;
Char_t          iend;
Int_t           iproc;
Int_t           itypin[2][2];
Float_t         amin[2];
Float_t         pin[2][3];
Int_t           np;
Int_t           ityp[600][6];   //[np]
Float_t         am[600];   //[np]
Float_t         pout[600][3];   //[np]

// List of branches
TBranch        *b_ieve;   //!
TBranch        *b_irun;   //!
TBranch        *b_iend;   //!
TBranch        *b_iproc;   //!
TBranch        *b_itypin;   //!
TBranch        *b_amin;   //!
TBranch        *b_pin;   //!
TBranch        *b_np;   //!
TBranch        *b_ityp;   //!
TBranch        *b_am;   //!
TBranch        *b_pout;   //!


Bool_t kSaveRootFile =kFALSE;//kFALSE;//kTRUE;
Bool_t kSaveCanvas = kFALSE;
TFile * rootfile;

//parameters 
TString stgt[__TARGETS]={"H1","D","He","H2","H3","H4"};//PVDIS H and D, SIDIS He, J/psi, SIDIS Proton, MOLLER proton
Double_t targth[__TARGETS]={40.0,40.0,40.0,15.0,3.0,150.0};
Double_t targ_A[__TARGETS]={1.0,2.0,3.0,1.0,1.0,1.0};
Double_t targ_Z[__TARGETS]={1.0,1.0,2.0,1.0,1.0,1.0};
Double_t ecurr[__TARGETS]={50.0,50.0,15.0,3.0,0.1,85.0}; 
Double_t targ_density[__TARGETS]={0.071,0.169,1.345e-3,0.071,0.917,0.071};
Double_t xlum[__TARGETS]; 
Double_t rate_LD_correction[__TARGETS];//={1.0,(0.169/2) / 0.071,(1.345e-3/3) / 0.071,1.0,0.0}; 
Double_t hd_total_rate[__TARGETS]={26261326.0,26261326.0,7878398.00,590879.81,0.0,167415952.00}; //in kHz for half target length for bremss rad length rate from 1M events 26261326.00 for J/Psi and MOLLER total rates are different since target lengths are different. The total interaction rate is computed in the hall D code given the target lenght and density
Int_t hd_tot_events[__TARGETS]={1e6,1e6,1e6,1e6,1e6,1e6}; //not in use, event size is accessed from the no. of entries in the ntuple
Double_t weight_rate[__TARGETS];//no. of pid is 5
Double_t weight_xs[__TARGETS];//no. of pid is 5
Double_t targ_offset[__TARGETS]={0.1,0.1, -3.50,-3.15,0.,0.};//in m
Double_t weight;
Int_t targ_index=0;
//pid status 
Int_t iPid[5]={0};

void compute4Target();//use this routine to calculate all the target len,lumi,rate and weight parameters for different targets

//text files for lund files
ofstream myfile[6];//for pi(+,-,0) and p and n, last index saves multi-track event lund file
Bool_t blundstatus[6]={kFALSE};
Bool_t bWriteLund = kTRUE;
Int_t nLundEntries=1e6;//no.of entires in each 
Int_t nEvent[6]={0};//for pi(+,-,0) and p and n, last index saves multi-track event lund file
Double_t totalRate[5]={0.0};
TRandom *r3[3];//for vertex

Double_t targ_length = 0.4;//m
Double_t rasterx_size = 0.004;//m
Double_t rastery_size = 0.004;//m
Double_t fEvV[3]={0.0};
std::map<int,double> pidmass;
std::map<int,int> pidcharge;
std::map<int,int> pid;
std::set<int> pid_set;
int track_pid;//for multi-track events
std::vector<int> track_index;

void set_plot_style();

int main(Int_t argc,Char_t* argv[]) { 

  
  gROOT->SetStyle("Plain");
  //gStyle->SetOptStat(0); 
  //gStyle->SetOptStat("eMr");
  gStyle->SetOptFit();
  TApplication theApp("App",&argc,argv);
  set_plot_style();

  pidmass[111]=134.9766/1000;//GeV pi0
  pidmass[211]=139.57018/1000;//GeV pi-
  pidmass[2212]=938.272/1000;//GeV proton
  pidmass[2112]=939.565/1000;//GeV neutron
  pidmass[11]=0.511/1000;//GeV electron
  pidmass[22]=0.0;//GeV photon
  pidmass[3112]=1197.449/1000;//GeV sigma-
  pidmass[3122]=1115.683/1000;//GeV lamda
  pidmass[3212]=1192.642/1000;//GeV sigma0 
  pidmass[3222]=1189.37/1000;//GeV sgima+
  pidmass[130]=497.648/1000;//GeV kaon0L
  pidmass[221]=547.862/1000;//GeV eta 
  pidmass[310]=497.648/1000;//GeV kaon0S
  pidmass[321]=493.667/1000;//GeV kaon+

  pidmass[-3112]=1197.449/1000;//GeV
  pidmass[-3122]=1115.683/1000;//GeV
  pidmass[-3212]=1192.642/1000;//GeV
  pidmass[-3222]=1189.37/1000;//GeV
  pidmass[-3312]=1321.71/1000;//GeV
  pidmass[-3322]=1314.86/1000;//GeV
  pidmass[-2212]=938.272/1000;//GeV
  pidmass[-2112]=939.565/1000;//GeV

  pidmass[-321]=493.667/1000;//GeV
  pidmass[-211]=139.57018/1000;//GeV
  pidmass[-11]=0.511/1000;//GeV


  pidcharge[111]=0;  
  pidcharge[211]=1;
  pidcharge[2112]=0;  
  pidcharge[2212]=1;
  pidcharge[11]=-1;//electron
  pidcharge[22]=0;// photon
  pidcharge[3112]=-1;// sigma-
  pidcharge[3122]=0;// lamda
  pidcharge[3212]=0;// sigma0 
  pidcharge[3222]=1;// sgima+
  pidcharge[130]=0;// kaon0L
  pidcharge[221]=0;// eta 
  pidcharge[310]=0;// kaon0S
  pidcharge[321]=1;// kaon+

  pidcharge[-3112]=1;//anti sigma-
  pidcharge[-3122]=0;//anti lamda
  pidcharge[-3212]=0;//anti sigma0
  pidcharge[-3222]=-1;//anti sgima+
  pidcharge[-3312]=1;//anti xi-
  pidcharge[-3322]=0;//anti xi0 
  pidcharge[-2212]=-1;//anti proton
  pidcharge[-2112]=0;//anti neutron

  pidcharge[-321]=-1;//kaon-
  pidcharge[-211]=-1;
  pidcharge[-11]=1;//positron



  pid[111]=1;  
  pid[-211]=2;
  pid[211]=0;
  pid[2212]=3;
  pid[2112]=4;  
  pid[1]=5;  //for multi track files


  compute4Target();
  //exit(1);
  targ_index=1;
  printf("Generating events for %s \n",stgt[targ_index].Data());

  //momentum bins
  Double_t mom_bin_min[__MOMENTUM_BINS] = {0.,1.,2.,3.,4.,5.};
  Double_t mom_bin_max[__MOMENTUM_BINS] = {1.,2.,3.,4.,5.,10.};
  Double_t theta_bin_min[__MOMENTUM_BINS] = {0.,0.,0.,0.,0.,0.};
  Double_t theta_bin_max[__MOMENTUM_BINS] = {180.,60.,40.,20.,20.,20.};
  Int_t theta_bins[__MOMENTUM_BINS] = {90.,30.,20.,10.,10.,10.};
  Double_t mom_bin_min1[__MOMENTUM_BINS1] = {0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9};
  Double_t mom_bin_max1[__MOMENTUM_BINS1] = {0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0};

  Int_t thetabins = 90;
  Double_t maxtheta = 90;
  Int_t mombins = 10;

  /*
  Double_t targth=40.0;//PVDIS 40 cm// JPsi 15 cm
  Double_t ecurr = 50.0E-6;//PVDIS 50 uA JPsi 3 uA
  Double_t xlum = ecurr/1.6E-19*targth*0.071*0.6022; //in [1/b] units for 40 cm LD2 target (nucleon luminosity)
  Double_t rate_LD_correction = 1 ; //no. of nucleons and density is the difference between LH2 and LD, Divide the total  interaction rate by the LH2 luminosity and then multiply by the LD target luminosity
  Double_t hd_total_rate = 37387712.00 * rate_LD_correction; //in kHz this with full target length used to compute bramss contribution
  hd_total_rate = 26261326.0 * rate_LD_correction; //in kHz for half target length for bremss rad length rate from 1M events 26261326.00 rate from 100k event 26239216.00
  //hd_total_rate = 590879.81;//in kHz for half target length for bremss rad length rate from 1M events for 15 cm at 3 uA
  Int_t hd_tot_events = 4e6;
  Double_t weight = hd_total_rate*1e3/hd_tot_events/xlum*1e6;//weighted by xs
  printf("weight factor for proton events : %f \n",weight);
  //exit(1);
  */

  TChain * halld_main = new TChain("h9");
  //halld_main->Add("/home/rakithab/Simulation_Analysis/Generators/HallD/ElectroProduction/bggen_output_hlf.root");//with 100k event
  //needs about 4M hall D events to generate 1M pions in forward angles (< 90 deg.)
  halld_main->Add("/home/rakithab/Simulation_Analysis/Generators/HallD/ElectroProduction/bggen_output_1M_*.root");//with 1M event with half target length used to compute bramss contribution  
  //halld_main->Add("/home/rakithab/Simulation_Analysis/Generators/HallD/ElectroProduction/bggen_output_Jpsi_1M.root");
  //halld_main->Add("/home/rakithab/Simulation_Analysis/Generators/HallD/ElectroProduction/bggen_output_Jpsi_1M_*.root");
  //for JPsi set 2 to 5
  //halld_main->Add("/home/rakithab/Simulation_Analysis/Generators/HallD/ElectroProduction/bggen_set5_output_Jpsi_1M_*.root");
  //for PVDIS and SIDIS set 2 to 5
  //halld_main->Add("/home/rakithab/Simulation_Analysis/Generators/HallD/ElectroProduction/bggen_set5_output_1M_*.root");//with 1M event with half target length used to compute bramss contribution  
  //for MOLLER set 1
  //halld_main->Add("/home/rakithab/Simulation_Analysis/Generators/HallD/ElectroProduction/bggen_set1_output_MOLLER_1M_*.root");

  halld_main->SetBranchAddress("ieve", &ieve, &b_ieve); //event no
  halld_main->SetBranchAddress("irun", &irun, &b_irun);
  halld_main->SetBranchAddress("iend", &iend, &b_iend);
  halld_main->SetBranchAddress("iproc", &iproc, &b_iproc);//process
  halld_main->SetBranchAddress("itypin", itypin, &b_itypin);
  halld_main->SetBranchAddress("amin", amin, &b_amin);
  halld_main->SetBranchAddress("pin", pin, &b_pin);//photon energy pin[0][2]
  halld_main->SetBranchAddress("np", &np, &b_np);//no.of particle per event
  halld_main->SetBranchAddress("ityp", ityp, &b_ityp);//ityp[][1]==1  is real output partilce and ityp[][2] is the pid of the particle (111,-211,211 and etc)
  halld_main->SetBranchAddress("am", am, &b_am);
  halld_main->SetBranchAddress("pout", pout, &b_pout);//output momentum pout[][0], pout[][1], pout[][2]
  
  //new root file
  TString rootfilename="/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/HallD_electroProd_Proton_40cm_e_11GeV_1M.root";
  rootfilename="/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/HallD_electroProd_Proton_15cm_e_11GeV_1M.root";
  rootfilename="/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/HallD_electroProd_Deuterium_40cm_e_11GeV_4M.root";
  if (kSaveRootFile){
    TString rootfilestatus="RECREATE";
    rootfile = new TFile(rootfilename, rootfilestatus);
    rootfile->cd();
  }


  //hall d histograms
  TH1F * pionmom[3][__MOMENTUM_BINS+1];//three pions in momentum bins and all momentum
  TH1F * pioncos[3][__MOMENTUM_BINS+1];//three pions in momentum bins and all momentum
  TH2F * pion2D[3][__MOMENTUM_BINS+1];//three pions in momentum bins and all momentum
  TH1F * Hadronsmom[2];//for neutrons and protons
  TH1F * Hadronscos[2];//for neutrons and protons
  TH2F * Hadrons2D[2];//for neutrons and protons

  TString pions[3]={"#pi^{0}","#pi^{-}","#pi^{+}"};
  for (Int_t i=0;i<__MOMENTUM_BINS;i++){
    for (Int_t j=0;j<3;j++){
      pionmom[j][i] = new TH1F(Form("pionmom_%i_%i",i,j),Form("Hall D %s Electro-Production :11 GeV electron on Proton; Momentum (GeV)",pions[j].Data()),10,mom_bin_min[i],mom_bin_max[i]);
      pioncos[j][i] = new TH1F(Form("pioncos_%i_%i",i,j),Form("Hall D %s Electro-Production :11 GeV electron on Proton (%1.0f to %1.0f GeV); #theta (deg)",pions[j].Data(),mom_bin_min[i],mom_bin_max[i]),thetabins,0,maxtheta);
      pion2D[j][i] = new TH2F(Form("pion2D_%i_%i",i,j),Form("Hall D %s Electro-Production :11 GeV electron on Proton (%1.1f to %1.1f GeV);Momentum (GeV); #theta (deg)",pions[j].Data(),mom_bin_min[i],mom_bin_max[i]),mombins,mom_bin_min[i],mom_bin_max[i],theta_bins[i],theta_bin_min[i],theta_bin_max[i]);
    }
  }
  //full range in momentum
  for(Int_t j=0;j<3;j++){
    pionmom[j][__MOMENTUM_BINS] = new TH1F(Form("pionmom_%i_%i",(Int_t)__MOMENTUM_BINS,j),Form("Hall D %s Electro-Production :11 GeV electron on Proton; Momentum (GeV)",pions[j].Data()),100,0,11);
    pioncos[j][__MOMENTUM_BINS] = new TH1F(Form("pioncos_%i_%i",(Int_t)__MOMENTUM_BINS,j),Form("Hall D %s Electro-Production :11 GeV electron on Proton (All mom.); #theta (deg)",pions[j].Data()),thetabins,0,maxtheta);
    pion2D[j][__MOMENTUM_BINS] = new TH2F(Form("pion2D_%i_%i",__MOMENTUM_BINS,j),Form("Hall D %s Electro-Production :11 GeV electron on Proton (0 to 11 GeV);Momentum (GeV); #theta (deg)",pions[j].Data()),100,0,11,thetabins,0,maxtheta);
  }
  Hadronsmom[0] = new TH1F("protonmom_all","Hall D Protons; Electro-Production :11 GeV electron on Proton; Momentum (GeV)",100,0,11);
  Hadronsmom[1] = new TH1F("neutronmom_all","Hall D Neutrons; Electro-Production :11 GeV electron on Proton; Momentum (GeV)",100,0,11);
  Hadronscos[0] = new TH1F("protoncos_all","Hall D Protons; Electro-Production :11 GeV electron on Proton; #theta (deg)",thetabins,0,maxtheta);
  Hadronscos[1] = new TH1F("neutroncos_all","Hall D Neutrons; Electro-Production :11 GeV electron on Proton; #theta (deg)",thetabins,0,maxtheta);
  Hadrons2D[0] = new TH2F("proton_all2D","Hall D Protons; Electro-Production :11 GeV electron on Proton (0 to 11 GeV);Momentum (GeV); #theta (deg)",100,0,11,thetabins,0,maxtheta);
  Hadrons2D[1] = new TH2F("neutron_all2D","Hall D Neutrons; Electro-Production :11 GeV electron on Proton (0 to 11 GeV);Momentum (GeV); #theta (deg)",100,0,11,thetabins,0,maxtheta);

  //only for pi0
  TH1F * pion0mom[__MOMENTUM_BINS1];
  TH1F * pion0cos[__MOMENTUM_BINS1];
  TH2F * pion02D[__MOMENTUM_BINS1];
  for (Int_t i=0;i<__MOMENTUM_BINS1;i++){
    pion0mom[i] = new TH1F(Form("pion0mom_%i",i),Form("Hall D #pi^{0} Electro-Production :11 GeV electron on Proton; Momentum (GeV)"),10,mom_bin_min1[i],mom_bin_max1[i]);
    pion0cos[i] = new TH1F(Form("pion0cos_%i",i),Form("Hall D #pi^{0} Electro-Production :11 GeV electron on Proton (%1.0f to %1.0f GeV); #theta (deg)",mom_bin_min1[i],mom_bin_max1[i]),thetabins,0,maxtheta);
    pion02D[i] = new TH2F(Form("pion02D_%i",i),Form("Hall D #pi^{0} Electro-Production :11 GeV electron on  Proton (%1.1f to %1.1f GeV);Momentum (GeV); #theta (deg)",mom_bin_min1[i],mom_bin_max1[i]),10,mom_bin_min1[i],mom_bin_max1[i],thetabins,0,maxtheta);//theta_bins1[i],0,theta_bin_max1[i]
  }

  Int_t hd_nentries = (Int_t)halld_main->GetEntries();
  hd_tot_events[0]=hd_nentries;
  hd_tot_events[1]=hd_nentries;
  hd_tot_events[2]=hd_nentries;
  hd_tot_events[3]=hd_nentries;
  hd_tot_events[4]=hd_nentries;
  hd_tot_events[5]=hd_nentries;

  printf("No.of enetries in the ntuple %i \n",hd_nentries);
  Double_t mom;
  Double_t th;
  Int_t mom_bin=0;
  Int_t mom_bin1=0;
  Double_t totalPions,totalBaryons;
  
  halld_main->Draw("TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2))>>pionpmom(1000,0,10)",Form("(ityp[][1]==1 && ityp[][2]==211 && TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2))>0 && TMath::ACos(pout[][2]/TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2) ))*180/TMath::Pi() < %f )*%f",maxtheta,hd_total_rate[targ_index]/hd_tot_events[targ_index]),"goff");
  TH1F * pionpmom = (TH1F *)gDirectory->Get("pionpmom");
  totalRate[0] = pionpmom->Integral()*1e3;//rate in Hz Pi+
  weight_rate[0] = totalRate[0];//totalRate[0]/pionpmom->GetEntries();
  totalPions=pionpmom->GetEntries();
  weight_xs[0] = weight_rate[0]/xlum[targ_index]*1e6;//xs in micro barn [ub]
  printf("Pi+ Total rate %3.3f MHz %3.3f mb\n",totalRate[0]/1e6,weight_xs[0]);
  halld_main->Draw("TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2))>>pion0mom_tmp(1000,0,10)",Form("(ityp[][1]==1 && ityp[][2]==111 && TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2))>0 && TMath::ACos(pout[][2]/TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2) ))*180/TMath::Pi() < %f )*%f",maxtheta,hd_total_rate[targ_index]/hd_tot_events[targ_index]),"goff");
  TH1F * pion0mom_tmp = (TH1F *)gDirectory->Get("pion0mom_tmp");
  totalRate[1] = pion0mom_tmp->Integral()*1e3;//rate in Hz  Pi0
  weight_rate[1] = totalRate[1];///pion0mom_tmp->GetEntries();
  weight_xs[1] = weight_rate[1]/xlum[targ_index]*1e6;//xs in micro barn [ub]
  printf("Pi0 Total rate %3.3f MHz %3.3f mb \n",totalRate[1]/1e6,weight_xs[1]);
  halld_main->Draw("TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2))>>pionmmom(1000,0,10)",Form("(ityp[][1]==1 && ityp[][2]==-211 && TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2))>0 && TMath::ACos(pout[][2]/TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2) ))*180/TMath::Pi() < %f )*%f",maxtheta,hd_total_rate[targ_index]/hd_tot_events[targ_index]),"goff");
  TH1F * pionmmom = (TH1F *)gDirectory->Get("pionmmom");
  totalRate[2] = pionmmom->Integral()*1e3;//rate in Hz Pi-
  weight_rate[2] = totalRate[2];//totalRate[2]/pionmmom->GetEntries();
  totalPions+=pionpmom->GetEntries();
  weight_xs[2] = weight_rate[2]/xlum[targ_index]*1e6;//xs in micro barn [ub]
  printf("Pi- Total rate %3.3f MHz %3.3f mb \n",totalRate[2]/1e6,weight_xs[2]);
  halld_main->Draw("TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2))>>protonmom(1000,0,10)",Form("(ityp[][1]==1 && ityp[][2]==2212 && TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2))>0 && TMath::ACos(pout[][2]/TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2) ))*180/TMath::Pi() < %f )*%f",maxtheta,hd_total_rate[targ_index]/hd_tot_events[targ_index]),"goff");
  TH1F * protonmom = (TH1F *)gDirectory->Get("protonmom");
  totalRate[3] = protonmom->Integral()*1e3;//rate in Hz Proton
  weight_rate[3] = totalRate[3];//totalRate[3]/protonmom->GetEntries();
  totalBaryons=protonmom->GetEntries();
  weight_xs[3] = weight_rate[3]/xlum[targ_index]*1e6;//xs in micro barn [ub]
  printf("Proton Total rate %3.3f MHz %3.3f mb \n",totalRate[3]/1e6,weight_xs[3]);
  halld_main->Draw("TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2))>>neutronmom(1000,0,10)",Form("(ityp[][1]==1 && ityp[][2]==2112 && TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2))>0 && TMath::ACos(pout[][2]/TMath::Sqrt(TMath::Power(pout[][0],2)+TMath::Power(pout[][1],2)+TMath::Power(pout[][2],2) ))*180/TMath::Pi() < %f )*%f",maxtheta,hd_total_rate[targ_index]/hd_tot_events[targ_index]),"goff");
  TH1F * neutronmom = (TH1F *)gDirectory->Get("neutronmom");
  totalRate[4] = neutronmom->Integral()*1e3;//rate in Hz Pi-
  weight_rate[4] = totalRate[4];//totalRate[4]/neutronmom->GetEntries();
  totalBaryons+=neutronmom->GetEntries();
  weight_xs[4] = weight_rate[4]/xlum[targ_index]*1e6;//xs in micro barn [ub]
  printf("Neutron Total rate %3.3f MHz %3.3f mb \n",totalRate[4]/1e6,weight_xs[4]);
  if (targ_A[targ_index]>1){
    printf(" Weight factors from proton pip %3.3e  pi0 %3.3e pim %3.3e p %3.3e n %3.3e \n",weight_xs[pid[211]],weight_xs[pid[111]],weight_xs[pid[-211]],weight_xs[pid[2212]],weight_xs[pid[2112]]);
    printf(" Total tracks  %6.0f, %6.0f, %6.0f, %6.0f, %6.0f \n",pionpmom->GetEntries(),pion0mom_tmp->GetEntries(),pionmmom->GetEntries(),protonmom->GetEntries(),neutronmom->GetEntries());
    printf("Weight factors for A>1 :  pip %3.3e  pi0 %3.3e pim %3.3e p %3.3e n %3.3e \n",((targ_A[targ_index] - targ_Z[targ_index])*weight_xs[pid[-211]] + targ_Z[targ_index]*weight_xs[pid[211]])/1,targ_A[targ_index]*weight_xs[pid[111]],((targ_A[targ_index] - targ_Z[targ_index])*weight_xs[pid[211]] + targ_Z[targ_index]*weight_xs[pid[-211]])/1,((targ_A[targ_index] - targ_Z[targ_index])*weight_xs[pid[2112]] + targ_Z[targ_index]*weight_xs[pid[2212]])/1,((targ_A[targ_index] - targ_Z[targ_index])*weight_xs[pid[2212]] + targ_Z[targ_index]*weight_xs[pid[2112]])/1);
    weight_xs[pid[211]]/=(pionpmom->GetEntries()+pionmmom->GetEntries());
    weight_xs[pid[-211]]/=(pionpmom->GetEntries()+pionmmom->GetEntries());
    weight_xs[pid[2112]]/=(protonmom->GetEntries()+neutronmom->GetEntries());
    weight_xs[pid[2212]]/=(protonmom->GetEntries()+neutronmom->GetEntries());
    weight_xs[pid[111]]/=pion0mom_tmp->GetEntries();
  }else{
    printf(" Weight factors from proton pip %3.3e  pi0 %3.3e pim %3.3e p %3.3e n %3.3e \n",weight_xs[pid[211]],weight_xs[pid[111]],weight_xs[pid[-211]],weight_xs[pid[2212]],weight_xs[pid[2112]]);
    printf(" Total tracks  %6.0f, %6.0f, %6.0f, %6.0f, %6.0f \n",pionpmom->GetEntries(),pion0mom_tmp->GetEntries(),pionmmom->GetEntries(),protonmom->GetEntries(),neutronmom->GetEntries());
    printf("Weight factors for A>1 :  pip %3.3e  pi0 %3.3e pim %3.3e p %3.3e n %3.3e \n",((targ_A[targ_index] - targ_Z[targ_index])*weight_xs[pid[-211]] + targ_Z[targ_index]*weight_xs[pid[211]])/1,targ_A[targ_index]*weight_xs[pid[111]],((targ_A[targ_index] - targ_Z[targ_index])*weight_xs[pid[211]] + targ_Z[targ_index]*weight_xs[pid[-211]])/1,((targ_A[targ_index] - targ_Z[targ_index])*weight_xs[pid[2112]] + targ_Z[targ_index]*weight_xs[pid[2212]])/1,((targ_A[targ_index] - targ_Z[targ_index])*weight_xs[pid[2212]] + targ_Z[targ_index]*weight_xs[pid[2112]])/1);    weight_xs[pid[111]]/=pion0mom_tmp->GetEntries();
    weight_xs[pid[211]]/=pionpmom->GetEntries();
    weight_xs[pid[-211]]/=pionmmom->GetEntries();
    weight_xs[pid[2112]]/=neutronmom->GetEntries();
    weight_xs[pid[2212]]/=protonmom->GetEntries();;
  }
  //following kinematics parameters are not in use for hadron backgrounds
  fEvQ2=0;
  fEvW2=0;
  fEvXbj=0;
  Wprate=0;
  Wmrate=0;
  y=0;
  
  if (bWriteLund){//for LUND format each event has the rate factor included. Therefore we need to know the total rate beforehand 
    //create LUND files
    myfile[0].open("hallD_pion_p_LD_1M_1.lund",ios::out);
    myfile[1].open("hallD_pion_0_LD_1M_1.lund",ios::out);
    myfile[2].open("hallD_pion_m_LD_1M_1.lund",ios::out);
    myfile[3].open("hallD_proton_LD_1M_1.lund",ios::out);
    myfile[4].open("hallD_neutron_LD_1M_1.lund",ios::out);
    myfile[5].open("hallD_LD_all_tracks_1M_1.lund",ios::out);

    r3[0] = new TRandom3(1);// for vertex x distribution
    r3[1] = new TRandom3(2);// for vertex y distribution
    r3[2] = new TRandom3(3);// for vertex z distribution
  }

  for (int i=0; i<hd_nentries ; i++) {
    halld_main->GetEntry(i);
    track_index.clear();//clear the track index vector begining of each event
    for (int j = 0; j<np; j++){
      if (ityp[j][1]==1){
	track_index.push_back(j);
	mom = TMath::Sqrt(TMath::Power(pout[j][0],2)+TMath::Power(pout[j][1],2)+TMath::Power(pout[j][2],2));
	th = TMath::ACos(pout[j][2]/TMath::Sqrt(TMath::Power(pout[j][0],2)+TMath::Power(pout[j][1],2)+TMath::Power(pout[j][2],2) ))*180/TMath::Pi();
	if (th < maxtheta){
	  for (Int_t k=0;k<__MOMENTUM_BINS;k++){	    
	    //cout<<"DEBUG 1 "<<mom_bin<<" "<<mom<<" "<<mom_bin_min[k]<<" "<<mom_bin_max[k] <<endl;
	    if (mom_bin_min[k]< mom && mom_bin_max[k]>= mom){
	      mom_bin = k;
	      if (k==0){
		for (Int_t k1=0;k1<__MOMENTUM_BINS1;k1++){	
		  if (mom_bin_min1[k1] < mom  && mom_bin_max1[k1] >= mom){
		    mom_bin1 = k1;
		    break;
		  }
		} 
	      }	      
	      break;
	    }else
	      mom_bin = -1;
	  }
	  //cout<<"DEBUG 2"<<mom_bin<<" "<<mom<<endl;
	  if (mom_bin < 0)
	    exit(1);

	  if (bWriteLund){
	    //determine the scattering vertex position in the target
	    if (rasterx_size>0)
	      fEvV[0] = r3[0]->Uniform(-1,1)*rasterx_size/2;
	    if (rastery_size>0)
	      fEvV[1] = r3[1]->Uniform(-1,1)*rastery_size/2;
	    fEvV[2] = r3[2]->Uniform(-1,1)*targth[targ_index]/100/2 + targ_offset[targ_index];	    
	  }
	  
	  if (ityp[j][2]==111){
	    //compute the total energy of the particle
	    weight = targ_A[targ_index]*weight_xs[pid[111]];
	    Ef=TMath::Sqrt(TMath::Power(mom,2) + TMath::Power(pidmass[111],2) );// subtract mass to get K.E - pidmass[pid];
	    pionmom[0][mom_bin]->Fill(mom,weight);
	    pioncos[0][mom_bin]->Fill(th,weight);
	    pion2D[0][mom_bin]->Fill(mom,th,weight);

	    pion0mom[mom_bin1]->Fill(mom,weight);
	    pion0cos[mom_bin1]->Fill(th,weight);
	    pion02D[mom_bin1]->Fill(mom,th,weight);
	    
	    pionmom[0][__MOMENTUM_BINS]->Fill(mom,weight);
	    pioncos[0][__MOMENTUM_BINS]->Fill(th,weight);
	    pion2D[0][__MOMENTUM_BINS]->Fill(mom,th,weight);

	    //save this event 
	    if (bWriteLund){
	      if (nEvent[pid[111]] < nLundEntries){
		myfile[pid[111]]<< "1" << " \t " << Wprate  << " \t " << Wmrate  << " \t " << "0"  << " \t " << "0" << " \t "  << fEvXbj << " \t " << y  << " \t " << fEvW2  << " \t " << fEvQ2  << " \t " << targ_A[targ_index]*totalRate[pid[111]]/nLundEntries << endl;
		myfile[pid[111]]<< " \t " << "1" << " \t " << pidcharge[111] << " \t " << "1" << " \t " << 111 << " \t " << "0" << " \t " << "0" << " \t " << pout[j][0] << " \t " << pout[j][1] << " \t " << pout[j][2] << " \t " << Ef << " \t " << pidmass[111] << " \t " << fEvV[0]*100  << " \t " << fEvV[1]*100 << " \t " << fEvV[2]*100 << endl;
	      } else if (!blundstatus[1])
		blundstatus[1]=kTRUE;
	      //increment hadron event count
	      nEvent[pid[111]]++;
	    }

	  }
	  if (ityp[j][2]==-211 || ityp[j][2]==211){
	    if (ityp[j][2]==-211){
	      iPid[pid[-211]]=1;
	      iPid[pid[211]]=0;
	    }
	    if (ityp[j][2]==211){
	      iPid[pid[-211]]=0;
	      iPid[pid[211]]=1;
	    }
	    if(targ_A[targ_index]>1){
	      iPid[pid[-211]]=1;
	      iPid[pid[211]]=1;
	    }
	    
	    //fill histograms
	    if (iPid[pid[-211]]>0){//pi-
	      weight = ((targ_A[targ_index] - targ_Z[targ_index])*weight_xs[pid[211]] + targ_Z[targ_index]*weight_xs[pid[-211]])/iPid[pid[-211]];
	      Ef=TMath::Sqrt(TMath::Power(mom,2) + TMath::Power(pidmass[-211],2) );// subtract mass to get K.E - pidmass[pid];
	      pionmom[1][mom_bin]->Fill(mom,weight);
	      pioncos[1][mom_bin]->Fill(th,weight);
	      pion2D[1][mom_bin]->Fill(mom,th,weight);
	      pionmom[1][__MOMENTUM_BINS]->Fill(mom,weight);
	      pioncos[1][__MOMENTUM_BINS]->Fill(th,weight);
	      pion2D[1][__MOMENTUM_BINS]->Fill(mom,th,weight);	      
	    }
	    if (iPid[pid[211]]>0){//pi+
	      weight = ((targ_A[targ_index] - targ_Z[targ_index])*weight_xs[pid[-211]] + targ_Z[targ_index]*weight_xs[pid[211]])/iPid[pid[211]];
	      Ef=TMath::Sqrt(TMath::Power(mom,2) + TMath::Power(pidmass[211],2) );// subtract mass to get K.E - pidmass[pid];
	      pionmom[2][mom_bin]->Fill(mom,weight);
	      pioncos[2][mom_bin]->Fill(th,weight);
	      pion2D[2][mom_bin]->Fill(mom,th,weight);
	      pionmom[2][__MOMENTUM_BINS]->Fill(mom,weight);
	      pioncos[2][__MOMENTUM_BINS]->Fill(th,weight);
	      pion2D[2][__MOMENTUM_BINS]->Fill(mom,th,weight);	      
	    }
	    //save this event 
	    if (bWriteLund){
	      if (nEvent[2] < nLundEntries && iPid[pid[-211]]>0){//pi-
		myfile[2]<< "1" << " \t " << Wprate  << " \t " << Wmrate  << " \t " << "0"  << " \t " << "0" << " \t "  << fEvXbj << " \t " << y  << " \t " << fEvW2  << " \t " << fEvQ2  << " \t " << ((targ_A[targ_index] - targ_Z[targ_index])*totalRate[pid[211]] + targ_Z[targ_index]*totalRate[pid[-211]])/iPid[pid[-211]]/nLundEntries << endl;
		myfile[2]<< " \t " << "1" << " \t " << pidcharge[-211] << " \t " << "1" << " \t " << -211 << " \t " << "0" << " \t " << "0" << " \t " << pout[j][0] << " \t " << pout[j][1] << " \t " << pout[j][2] << " \t " << Ef << " \t " << pidmass[-211] << " \t " << fEvV[0]*100  << " \t " << fEvV[1]*100 << " \t " << fEvV[2]*100 << endl;
	      } else if (!blundstatus[2])
		blundstatus[2]=kTRUE;
	      //increment hadron event count
	      if (iPid[pid[-211]]>0)
		nEvent[2]++;
	      if (nEvent[0] < nLundEntries && iPid[pid[211]]>0){//pi+
		myfile[0]<< "1" << " \t " << Wprate  << " \t " << Wmrate  << " \t " << "0"  << " \t " << "0" << " \t "  << fEvXbj << " \t " << y  << " \t " << fEvW2  << " \t " << fEvQ2  << " \t " << (targ_Z[targ_index]*totalRate[pid[211]] + (targ_A[targ_index] - targ_Z[targ_index])*totalRate[pid[-211]])/iPid[pid[211]]/nLundEntries << endl;
		myfile[0]<< " \t " << "1" << " \t " << pidcharge[211] << " \t " << "1" << " \t " << 211 << " \t " << "0" << " \t " << "0" << " \t " << pout[j][0] << " \t " << pout[j][1] << " \t " << pout[j][2] << " \t " << Ef << " \t " << pidmass[211] << " \t " << fEvV[0]*100  << " \t " << fEvV[1]*100 << " \t " << fEvV[2]*100 << endl;
	      } else if (!blundstatus[0])
		blundstatus[0]=kTRUE;
	      //increment hadron event count
	      if (iPid[pid[211]]>0)
		nEvent[0]++;
	      
	    }	  

	  }
	  /*
	  if (ityp[j][2]==211){
	    Ef=TMath::Sqrt(TMath::Power(mom,2) + TMath::Power(pidmass[211],2) );// subtract mass to get K.E - pidmass[pid];
	    pionmom[2][mom_bin]->Fill(mom,weight_xs[targ_index]);
	    pioncos[2][mom_bin]->Fill(th,weight_xs[targ_index]);
	    pion2D[2][mom_bin]->Fill(mom,th,weight_xs[targ_index]);
	    pionmom[2][__MOMENTUM_BINS]->Fill(mom,weight_xs[targ_index]);
	    pioncos[2][__MOMENTUM_BINS]->Fill(th,weight_xs[targ_index]);
	    pion2D[2][__MOMENTUM_BINS]->Fill(mom,th,weight_xs[targ_index]);
	    //save this event 
	    if (bWriteLund){
	      if (nEvent[0] < nLundEntries){
		myfile[0]<< "1" << " \t " << Wprate  << " \t " << Wmrate  << " \t " << "0"  << " \t " << "0" << " \t "  << fEvXbj << " \t " << y  << " \t " << fEvW2  << " \t " << fEvQ2  << " \t " << totalRate[0]/nLundEntries << endl;
		myfile[0]<< " \t " << "1" << " \t " << pidcharge[211] << " \t " << "1" << " \t " << 211 << " \t " << "0" << " \t " << "0" << " \t " << pout[j][0] << " \t " << pout[j][1] << " \t " << pout[j][2] << " \t " << Ef << " \t " << pidmass[211] << " \t " << fEvV[0]*100  << " \t " << fEvV[1]*100 << " \t " << fEvV[2]*100 << endl;
	      } else if (!blundstatus[0])
		blundstatus[0]=kTRUE;
	      //increment hadron event count
	      nEvent[0]++;
	    }
	  }
	  */
	  if (ityp[j][2]==2212 || ityp[j][2]==2112){
	    if (ityp[j][2]==2212){
	      iPid[pid[2212]]=1;
	      iPid[pid[2112]]=0;
	    }
	    if (ityp[j][2]==2112){
	      iPid[pid[2212]]=0;
	      iPid[pid[2112]]=1;
	    }
	    if(targ_A[targ_index]>1){
	      iPid[pid[2212]]=1;
	      iPid[pid[2112]]=1;
	    }
	    if (iPid[pid[2212]]>0){//proton
	      weight = ((targ_A[targ_index] - targ_Z[targ_index])*weight_xs[pid[2112]] + targ_Z[targ_index]*weight_xs[pid[2212]])/iPid[pid[2212]];
	      Ef=TMath::Sqrt(TMath::Power(mom,2) + TMath::Power(pidmass[2212],2) );// subtract mass to get K.E - pidmass[pid];
	      Hadronsmom[0]->Fill(mom,weight);
	      Hadronscos[0]->Fill(th,weight);
	      Hadrons2D[0]->Fill(mom,th,weight);
	    }
	    if (iPid[pid[2112]]>0){//neutron
	      weight = ((targ_A[targ_index] - targ_Z[targ_index])*weight_xs[pid[2212]] + targ_Z[targ_index]*weight_xs[pid[2112]])/iPid[pid[2112]];
	      Ef=TMath::Sqrt(TMath::Power(mom,2) + TMath::Power(pidmass[2112],2) );// subtract mass to get K.E - pidmass[pid];
	      Hadronsmom[1]->Fill(mom,weight);
	      Hadronscos[1]->Fill(th,weight);
	      Hadrons2D[1]->Fill(mom,th,weight);
	    }
	    //save this event 
	    if (bWriteLund){
	      if (nEvent[3] < nLundEntries && iPid[pid[2212]]>0){//proton
		myfile[3]<< "1" << " \t " << Wprate  << " \t " << Wmrate  << " \t " << "0"  << " \t " << "0" << " \t "  << fEvXbj << " \t " << y  << " \t " << fEvW2  << " \t " << fEvQ2  << " \t " << ( (targ_A[targ_index] - targ_Z[targ_index])*totalRate[pid[2112]] + targ_Z[targ_index]*totalRate[pid[2212]])/iPid[pid[2212]]/nLundEntries << endl;
		myfile[3]<< " \t " << "1" << " \t " << pidcharge[2212] << " \t " << "1" << " \t " << 2212 << " \t " << "0" << " \t " << "0" << " \t " << pout[j][0] << " \t " << pout[j][1] << " \t " << pout[j][2] << " \t " << Ef << " \t " << pidmass[2212] << " \t " << fEvV[0]*100  << " \t " << fEvV[1]*100 << " \t " << fEvV[2]*100 << endl;
	      } else if (!blundstatus[3])
		blundstatus[3]=kTRUE;
	      //increment hadron event count
	      if (iPid[pid[2212]]>0)
		nEvent[pid[2212]]++;
	      if (nEvent[4] < nLundEntries && iPid[pid[2112]]>0){//neutron
		myfile[4]<< "1" << " \t " << Wprate  << " \t " << Wmrate  << " \t " << "0"  << " \t " << "0" << " \t "  << fEvXbj << " \t " << y  << " \t " << fEvW2  << " \t " << fEvQ2  << " \t " << ( (targ_A[targ_index] - targ_Z[targ_index])*totalRate[pid[2212]] + targ_Z[targ_index]*totalRate[pid[2112]])/iPid[pid[2112]]/nLundEntries << endl;
		myfile[4]<< " \t " << "1" << " \t " << pidcharge[2112] << " \t " << "1" << " \t " << 2112 << " \t " << "0" << " \t " << "0" << " \t " << pout[j][0] << " \t " << pout[j][1] << " \t " << pout[j][2] << " \t " << Ef << " \t " << pidmass[2112] << " \t " << fEvV[0]*100  << " \t " << fEvV[1]*100 << " \t " << fEvV[2]*100 << endl;
	      } else if (!blundstatus[4])
		blundstatus[4]=kTRUE;
	      //increment hadron event count
	      if (iPid[pid[2112]]>0)
	      nEvent[pid[2112]]++;	      
	    }
	  }
	  /*
	  if (ityp[j][2]==2112){
	    Ef=TMath::Sqrt(TMath::Power(mom,2) + TMath::Power(pidmass[2112],2) );// subtract mass to get K.E - pidmass[pid];
	    Hadronsmom[1]->Fill(mom,weight_xs[targ_index]);
	    Hadronscos[1]->Fill(th,weight_xs[targ_index]);
	    Hadrons2D[1]->Fill(mom,th,weight_xs[targ_index]);
	    //save this event 
	    if (bWriteLund){
	      if (nEvent[4] < nLundEntries){
		myfile[4]<< "1" << " \t " << Wprate  << " \t " << Wmrate  << " \t " << "0"  << " \t " << "0" << " \t "  << fEvXbj << " \t " << y  << " \t " << fEvW2  << " \t " << fEvQ2  << " \t " << totalRate[4]/nLundEntries << endl;
		myfile[4]<< " \t " << "1" << " \t " << pidcharge[2112] << " \t " << "1" << " \t " << 2112 << " \t " << "0" << " \t " << "0" << " \t " << pout[j][0] << " \t " << pout[j][1] << " \t " << pout[j][2] << " \t " << Ef << " \t " << pidmass[2112] << " \t " << fEvV[0]*100  << " \t " << fEvV[1]*100 << " \t " << fEvV[2]*100 << endl;
	      } else if (!blundstatus[4])
		blundstatus[4]=kTRUE;
	      //increment hadron event count
	      nEvent[4]++;
	    }	  
	  }
	  */
	}
      }

    }
    //lund file with multi particle states
    if (bWriteLund){
      if (nEvent[pid[1]] < nLundEntries){//pid=1 is used for multi-track events
	myfile[pid[1]]<< track_index.size() << " \t " << Wprate  << " \t " << Wmrate  << " \t " << "0"  << " \t " << "0" << " \t "  << fEvXbj << " \t " << y  << " \t " << fEvW2  << " \t " << fEvQ2  << " \t " << targ_A[targ_index]*hd_total_rate[targ_index]*1e3/nLundEntries << endl;
	Int_t j=0;//track id
	for(Int_t k=0;k<track_index.size();k++){
	  j=track_index[k];
	  track_pid=ityp[j][2];
	  /*
	  if(pid_set.count(track_pid)==0 )
	    pid_set.insert(track_pid);
	  */
	  mom = TMath::Sqrt(TMath::Power(pout[j][0],2)+TMath::Power(pout[j][1],2)+TMath::Power(pout[j][2],2));
	  Ef=TMath::Sqrt(TMath::Power(mom,2) + TMath::Power(pidmass[track_pid],2) );// subtract mass to get K.E - pidmass[pid];
	  myfile[pid[1]]<< " \t " << k+1 << " \t " << pidcharge[track_pid] << " \t " << "1" << " \t " << track_pid << " \t " << "0" << " \t " << "0" << " \t " << pout[j][0] << " \t " << pout[j][1] << " \t " << pout[j][2] << " \t " << Ef << " \t " << pidmass[track_pid] << " \t " << fEvV[0]*100  << " \t " << fEvV[1]*100 << " \t " << fEvV[2]*100 << endl;
	}
      } else if (!blundstatus[5])
	blundstatus[5]=kTRUE;
      nEvent[pid[1]]++;
    }
  }

  Double_t pion_xs[3][__MOMENTUM_BINS+1]={{0}};
  Double_t pion0_xs[__MOMENTUM_BINS1]={0};

  //TCanvas * canvas_pion[3][__MOMENTUM_BINS+1];
  TCanvas * canvas_pionmom[3];
  TCanvas * canvas_pioncos[3];
  TCanvas * canvas_pion2D[3];
  TCanvas * canvas_pion2D_all = new TCanvas("canvas_pion2D_all","canvas_pion2D_all",1500,450);
  TCanvas * canvas_pionmom_all = new TCanvas("canvas_pionmom_all","canvas_pionmom_all",1500,450);
  TCanvas * canvas_pioncos_all = new TCanvas("canvas_pioncos_all","canvas_pioncos_all",1500,450);
  canvas_pion2D_all->Divide(3,1); 
  canvas_pionmom_all->Divide(3,1); 
  canvas_pioncos_all->Divide(3,1); 

  for (Int_t j=0;j<3;j++){
    canvas_pion2D[j] = new TCanvas(Form("canvas_pion2D_%i",j),Form("canvas_pion2D_%i",j),1500,650);
    canvas_pion2D[j]->Divide(3,2);  
    canvas_pionmom[j] = new TCanvas(Form("canvas_pionmom_%i",j),Form("canvas_pionmom_%i",j),1500,650);
    canvas_pionmom[j]->Divide(3,2);  
    canvas_pioncos[j] = new TCanvas(Form("canvas_pioncos_%i",j),Form("canvas_pioncos_%i",j),1500,650);
    canvas_pioncos[j]->Divide(3,2);  

    for (Int_t i=0;i < (__MOMENTUM_BINS);i++){
      //canvas_pion[j][i] = new TCanvas(Form("canvas_pion_%i_%i",i,j),Form("canvas_pion_%i_%i",i,j),850,650);
      //canvas_pion[j][i]->Divide(1,2);  
      //canvas_pion[j][i]->cd(1);
      canvas_pionmom[j]->cd(i+1);
      pionmom[j][i]->Draw();
      pion_xs[j][i]=pionmom[j][i]->Integral();
      //canvas_pion[j][i]->cd(2);
      canvas_pioncos[j]->cd(i+1);
      pioncos[j][i]->Draw();
      canvas_pion2D[j]->cd(i+1);
      pion2D[j][i]->SetStats(0);
      pion2D[j][i]->Draw("colz");
      if (j==2)
	printf("%2.0f - %2.0f %13.3f %10.2f %13.3f %10.2f %13.3f %10.2f \n",mom_bin_min[i],mom_bin_max[i],pion_xs[0][i],pion_xs[0][i]*xlum[targ_index]/1e6/1e6,pion_xs[1][i],pion_xs[1][i]*xlum[targ_index]/1e6/1e6,pion_xs[2][i],pion_xs[2][i]*xlum[targ_index]/1e6/1e6);
    }
    if (kSaveCanvas){
      canvas_pionmom[j]->SaveAs(Form("/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/Generators/HallD_Proton_pion_%i_momBins_1M.png",j)); 
      canvas_pioncos[j]->SaveAs(Form("/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/Generators/HallD_Proton_pion_%i_cosBins_1M.png",j)); 
      canvas_pion2D[j]->SaveAs(Form("/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/Generators/HallD_Proton_pion_%i_2DBins_1M.png",j)); 
    }
    canvas_pion2D_all->cd(j+1);
    pion2D[j][__MOMENTUM_BINS]->Draw("colz");
    canvas_pionmom_all->cd(j+1);
    pionmom[j][__MOMENTUM_BINS]->Draw();
    canvas_pioncos_all->cd(j+1);
    pioncos[j][__MOMENTUM_BINS]->Draw();
  }
  if (kSaveCanvas){
    canvas_pion2D_all->SaveAs(Form("/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/Generators/HallD_Proton_pions_2DAll_1M.png")); 
    canvas_pionmom_all->SaveAs(Form("/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/Generators/HallD_Proton_pions_momAll_1M.png")); 
    canvas_pioncos_all->SaveAs(Form("/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/Generators/HallD_Proton_pions_cosAll_1M.png"));   
  }

  TCanvas * canvas_hadron2D_all = new TCanvas("canvas_hadron2D_all","canvas_hadron2D_all",1500,450);
  TCanvas * canvas_hadronmom_all = new TCanvas("canvas_hadronmom_all","canvas_hadronmom_all",1500,450);
  TCanvas * canvas_hadroncos_all = new TCanvas("canvas_hadroncos_all","canvas_hadroncos_all",1500,450);
  canvas_hadron2D_all->Divide(2,1); 
  canvas_hadronmom_all->Divide(2,1); 
  canvas_hadroncos_all->Divide(2,1);

  for (Int_t j=0;j<2;j++){
    canvas_hadronmom_all->cd(j+1);
    Hadronsmom[j]->Draw();
    canvas_hadroncos_all->cd(j+1);
    Hadronscos[j]->Draw();
    canvas_hadron2D_all->cd(j+1);
    Hadrons2D[j]->Draw("colz");
  }
  if (kSaveCanvas){
    canvas_hadron2D_all->SaveAs(Form("/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/Generators/HallD_Proton_hadrons_2DAll_1M.png")); 
    canvas_hadronmom_all->SaveAs(Form("/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/Generators/HallD_Proton_hadrons_momAll_1M.png")); 
    canvas_hadroncos_all->SaveAs(Form("/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/Generators/HallD_Proton_hadrons_cosAll_1M.png"));   
  }

  //TCanvas * canvas_pion0[__MOMENTUM_BINS1];
  TCanvas * canvas_pion0mom = new TCanvas("canvas_pion0mom","canvas_pion0mom",1750,650);
  canvas_pion0mom->Divide(5,2);  
  TCanvas * canvas_pion0cos = new TCanvas("canvas_pion0cos","canvas_pion0cos",1750,650);
  canvas_pion0cos->Divide(5,2);  
  TCanvas * canvas_pion02D = new TCanvas("canvas_pion02D","canvas_pion02D",1750,650);
  canvas_pion02D->Divide(5,2);

  for (Int_t i=0;i < (__MOMENTUM_BINS1);i++){
    //canvas_pion0[i] = new TCanvas(Form("canvas_pion0_%i",i),Form("canvas_pion0_%i",i),850,650);
    //canvas_pion0[i]->Divide(1,2);  
    //canvas_pion0[i]->cd(1);
    canvas_pion0mom->cd(i+1);
    pion0mom[i]->Draw();
    pion0_xs[i]=pion0mom[i]->Integral();
    //canvas_pion0[i]->cd(2);
    canvas_pion0cos->cd(i+1);
    pion0cos[i]->Draw();
    canvas_pion02D->cd(i+1);
    pion02D[i]->SetStats(0);
    pion02D[i]->Draw("colz");
    printf("%2.1f - %2.1f %13.3f %10.2f  \n",mom_bin_min1[i],mom_bin_max1[i],pion0_xs[i],pion0_xs[i]*xlum[targ_index]/1e6/1e6);
  }

  if (kSaveCanvas){
    canvas_pion0mom->SaveAs(Form("/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/Generators/HallD_Proton_pion0_momFineBins_1M.png")); 
    canvas_pion0cos->SaveAs(Form("/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/Generators/HallD_Proton_pion0_cosFineBins_1M.png")); 
    canvas_pion02D->SaveAs(Form("/home/rakithab/Simulation_Analysis/Remoll/SoLID/Plots/Generators/HallD_Proton_pion0_2DFineBins_1M.png")); 
  }
  /*
  //print unique pid list
  std::set<int>::iterator it;
  for(it=pid_set.begin(); it!=pid_set.end(); ++it){
    std::cout << ' ' << *it<<std::endl;
  }
  */

  if (kSaveRootFile){
    rootfile->Write();
  }

  if (bWriteLund){
    for (Int_t i=0;i<6;i++)
      myfile[i].close();
  }
  theApp.Run();
  if (kSaveRootFile){
    rootfile->Close();
  }
  return(1);
}

void compute4Target(){
  for(Int_t i=0;i<__TARGETS;i++){
    rate_LD_correction[i] = targ_density[i]/targ_A[i]/targ_density[0];
    hd_total_rate[i]*=rate_LD_correction[i];
    xlum[i] = ecurr[i]/1.6E-19*targth[i]*targ_density[i]/targ_A[i]*0.6022*1e-6;
    printf(" %f \t %f \t %f \n", xlum[i], hd_total_rate[i], hd_total_rate[i]/xlum[i]);
    //weight_rate[i] = hd_total_rate[i]/hd_tot_events[i]*targ_A[i];
    //weight_xs[i] = hd_total_rate[i]*1e3/hd_tot_events[i]/xlum[i]*1e6*targ_A[i];//weighted by xs
  }
};

void set_plot_style()
{
    const Int_t NRGBs = 5;
    const Int_t NCont = 255;

    Double_t stops[NRGBs] = { 0.00, 0.34, 0.61, 0.84, 1.00 };
    Double_t red[NRGBs]   = { 0.00, 0.00, 0.87, 1.00, 0.51 };
    Double_t green[NRGBs] = { 0.00, 0.81, 1.00, 0.20, 0.00 };
    Double_t blue[NRGBs]  = { 0.51, 1.00, 0.12, 0.00, 0.00 };
    TColor::CreateGradientColorTable(NRGBs, stops, red, green, blue, NCont);
    gStyle->SetNumberContours(NCont);
}
 

